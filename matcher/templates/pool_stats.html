{% load static %}

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Loading…</title>
		<meta charset="utf-8" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.15.1/d3.min.js" integrity="sha256-SQJ/nCYPXFPuqoS56EfnesDBPNiitndOIfN2WdPRi/o=" crossorigin="anonymous"></script>
		<style>
      body {
        margin: 0;
        font-family: Helvetica, Arial, sans-serif;
      }

      h1 {
        font-size: 2em;
        margin: 0;
      }

      aside {
        position: absolute;
        top: 20px;
        left: 20px;
        box-shadow: 0 5px 20px rgba(0,0,0, 0.25);
        border: 1px solid rgba(0,0,0, 0.15);
        background-color: rgba(255,255,255, 0.8);
        padding: 1em;
      }

      aside h2 {
        margin-bottom: 0.25em;
      }

      aside p {
        margin-top: 0;
      }

      aside #stats {
        list-style-type: none;
        padding: 0;
        margin: 0.5em 0;
        font-size: 1.2em;
        color: #666;
      }

      aside #stats li {
        display: inline;
        margin-right: 0.5em;
      }

      aside #stats .stat {
        font-weight: bold;
      }

      table {
        border-collapse: collapse;
      }

      table, th, td {
        border: 1px solid rgba(0,0,0, 0.2);
        padding: 0.2em 0.4em;
      }

      th {
        color: white;
        background-color: #2c2e2f;
      }

      tr:nth-child(even) {
        background-color: rgba(0,0,0, 0.05);
      }

      table th {
        text-align: left;
      }

      #leaderboard {
        max-height: 280px;
        overflow-y: scroll;
        box-shadow: 0 -10px 5px -5px rgba(0,0,0, 0.2) inset
      }

      #legend {
        position: absolute;
        top: 20px;
        right: 20px;
        max-width: 480px;
        line-height: 1.4;
        color: #666;
      }

      figure {
        margin: 0;
      }

			circle {
				fill: #50c7f9;
        fill-opacity: 0.4;
				stroke: white;
        stroke-width: 2;
			}

			text {
        font-size: 0.8em;
				font-family: Helvetica, Arial, sans-serif;
				text-shadow: 1px 1px white, 0 0 4px white;
				cursor: default;
			}

			line {
				stroke: #b7bcbf;
				stroke-width: 2;
				stroke-opacity: 0.2;
			}

			line.met {
				stroke: #ff9600;
			}

			line.selected {
				stroke-opacity: 1;
        stroke-width: 3;
			}

      .person:hover circle, .person.selected circle {
				fill-opacity: 1;
			}
		</style>
	</head>
	<body>

    <aside>
      <h1 id="pool-name"></h1>
      <ul id="stats">
        <li><span id="member-count" class="stat"></span> members</li>
        <li><span id="round-count" class="stat"></span> rounds</li>
      </ul>
      <h2>Leaderboard</h2>
      <p>Who’s met the most people:</p>
      <div id="leaderboard">
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Name</th>
              <th>Met</th>            
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </aside>

    <div id="legend">
      Circles are sized based on the number of people each person has met. Hover over a circle to see a person’s pairings. Orange lines show pairings that actually met, while gray lines show pairings that didn’t. This visualization looks best on a larger display.
    </div>

		<figure>
    </figure>

		<script>
			const width = window.innerWidth,
            height = window.innerWidth;
      
			async function main() {
        // make API request to get pool data
        const pathParts = window.location.pathname.split('/').filter(x => x),
          channelName = pathParts[pathParts.length - 1],
          pool = await fetch(`/api/stats/${channelName}`).then(res => res.json());
          
        // update text on the page
        document.getElementById('pool-name').innerText = pool.name;
        document.getElementById('member-count').innerText = pool.member_count;
        document.getElementById('round-count').innerText = pool.round_count;
        document.title = `${pool.name} statistics`;

        // populate the leaderboard
        const leaderboard = document.querySelector('#leaderboard tbody');
        pool.people = pool.people.map(person => Object.assign(person, {
            people_met: pool.matches.reduce((acc, cur) =>
              cur.met && (cur.person_1 === person.id || cur.person_2 === person.id) ? acc + 1 : acc, 0)
        }));
        let curRank = 1;
        pool.people
        .sort((a, b) => b.people_met - a.people_met)
        .forEach((person, index, people) => {
          const tr = document.createElement('tr');
          if (people[index-1] && people[index-1].people_met > person.people_met) {
            curRank++;
          }
          tr.innerHTML = `
            <td><strong>${curRank}</strong></td>
            <td>${person.full_name}</td>
            <td>${person.people_met}</td>
          `
          leaderboard.appendChild(tr);
        })

        // D3 simulation setup
        const links = pool.matches.map(match => ({
          source: match.person_1,
          target: match.person_2,
          met: match.met 
        })),
          nodes = pool.people;

        const simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id))
          .force('charge', d3.forceManyBody())
          .force('center', d3.forceCenter(width / 2, height / 2))
          .force('collide', d3.forceCollide(d => boundingBox(d)));

        const svg = d3.select('figure').append('svg')
          .attr('viewBox', [0, 0, width, height]);

        const link = svg.append('g')
          .attr('class', 'links')
          .selectAll('line')
          .data(links)
          .join('line')
          .attr('class', d => 
            `person-${d.source.id} ${d.met ? 'met' : ''} person-${d.target.id}`
          );

        const node = svg.append('g')
          .attr('class', 'nodes')
          .selectAll('g')
          .data(nodes)
          .enter().append('g')
          .attr('class', d => {
            const matchedWith = pool.matches
            .filter(match => match.person_1 === d.id || match.person_2 === d.id)
            .map(match => match.person_1 === d.id ? `person-${match.person_2}` : `person-${match.person_1}`)
            .join(' ')
            return `person person-${d.id} ${matchedWith}`
          })
          .call(drag(simulation))
          .on('mouseover', mouseover)
          .on('mouseout', mouseout);

        node.append('circle')
          .attr('fill', 'gray')
          .attr('r', d => (d.people_met * 2.5) + 5);

        node.append('text')
          .text(d => d.full_name)
          .attr('text-anchor', 'middle')
          .attr('y', '0.35em');

        simulation.on('tick', () => {
          link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
          node
            .attr('transform', d => `translate(${d.x},${d.y})`)
        });


        // UTILITY FUNCTIONS

        // specifies the size of the node's collision bounds.
        // derive from category name length for long names to prevent overlap
        function boundingBox(d) {
          return Math.max(d.full_name.length * 3.4, d.people_met * 2.5);
        }
        
        function mouseover(d) {
          document.querySelectorAll(`.person-${d.id}`)
          .forEach(el => {
            el.classList.add('selected');
          });
        }

        function mouseout(d) {
          document.querySelectorAll(`.person-${d.id}`)
          .forEach(el => {
            el.classList.remove('selected');
          });
        }
        
        function drag(simulation) {
          const dragstarted = d => {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }
          
          const dragged = d => {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          }
          
          const dragended = d => {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }
          
          return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
        }
			}
			main();
		</script>
	</body>
</html>